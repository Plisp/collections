(in-package #:cl.lisp.collections.test)

(define-test bst/make-tree
  (let ((tree (bst:make-tree)))
    (of-type bst::tree tree)
    (false (bst::root tree))
    (is eq #'identity (bst::key tree))
    (is eq #'< (bst::test tree))))

(define-test bst/valid-p
  (dotimes (i 10)
    (let ((tree (bst:make-tree)))
      (dotimes (i 1000)
        (bst:insert tree (random 1d0)))
      (true (bst:valid-p tree))))
  (let ((tree (bst:make-tree)))
    (dotimes (i 10)
      (bst:insert tree (1+ i)))
    (setf (bst::data (bst::root tree)) 42)
    (false (bst:valid-p tree))))

(define-test bst/walk
  (let ((tree (bst:make-tree))
        (input '(8 2 5 1 4 9 3 10 7 6))
        (result nil))
    (false (bst:walk tree))
    (dotimes (i 10)
      (bst:insert tree (pop input)))
    (false (bst:walk tree))
    (bst:walk tree (lambda (x) (push (* x 10) result)))
    (is equal '(10 20 30 40 50 60 70 80 90 100) (reverse result))))

(define-test bst/find
  (let ((tree (bst:make-tree)))
    (false (bst:find tree 42))
    (bst:insert tree 420)
    (bst:insert tree 621)
    (dotimes (i 1000)
      (bst:insert tree (random 1000.0)))
    (is = 420 (bst:find tree 420))
    (of-type bst::node (nth-value 1 (bst:find tree 621)))
    (setf tree (bst:make-tree :key #'cdr))
    (bst:insert tree '(:foo . 420))
    (dotimes (i 1000)
      (bst:insert tree `(:bar . ,(random 1000.0))))
    (is = 420 (cdr (bst:find tree 420)))
    (fail (bst:find tree :foo))
    (fail (bst:find tree '(:foo . 420)))))

(define-test bst/insert
  (let ((tree (bst:make-tree)))
    (of-type bst::node (bst:insert tree 42))
    (is = 42 (bst:find tree 42))))

(define-test bst/delete
  (let ((tree (bst:make-tree)))
    (of-type bst::tree (bst:delete tree 1))
    (false (nth-value 1 (bst:delete tree 1)))
    (dotimes (i 1000)
      (bst:insert tree (1+ i)))
    (true (nth-value 1 (bst:delete tree 1)))
    (false (bst:find tree 1))
    (setf tree (bst:make-tree :key #'cdr))
    (bst:insert tree '(:foo . 1))
    (dotimes (i 1000)
      (bst:insert tree `(:bar . ,(+ 2 (random 1000.0)))))
    (true (nth-value 1 (bst:delete tree 1)))
    (false (bst:find tree 1))))

(define-test bst/min
  (let ((tree (bst:make-tree)))
    (false (bst:min tree))
    (dotimes (i 1000)
      (bst:insert tree (1+ i)))
    (is = 1 (bst:min tree))
    (setf tree (bst:make-tree :key #'cdr))
    (dotimes (i 200)
      (bst:insert tree `(:foo . ,(+ 200 (random 200.0)))))
    (bst:insert tree '(:bar . 199))
    (bst:insert tree '(:baz . 50))
    (dotimes (i 500)
      (bst:insert tree `(:qux . ,(+ 400 (random 500.0)))))
    (is = 50 (cdr (bst:min tree)))
    (bst:delete tree 50)
    (is = 199 (cdr (bst:min tree)))))

(define-test bst/max
  (let ((tree (bst:make-tree)))
    (false (bst:max tree))
    (dotimes (i 1000)
      (bst:insert tree (1+ i)))
    (is = 1000 (bst:max tree))
    (setf tree (bst:make-tree :key #'cdr))
    (dotimes (i 200)
      (bst:insert tree `(:foo . ,(random 200.0))))
    (bst:insert tree '(:bar . 700))
    (bst:insert tree '(:baz . 999))
    (dotimes (i 500)
      (bst:insert tree `(:qux . ,(+ 200 (random 500.0)))))
    (is = 999 (cdr (bst:max tree)))
    (bst:delete tree 999)
    (is = 700 (cdr (bst:max tree)))))

(define-test bst/previous
  (let ((tree (bst:make-tree)))
    (dotimes (i 100)
      (bst:insert tree (1+ i)))
    (is = 99 (bst:previous (nth-value 1 (bst:find tree 100))))
    (bst:delete tree 99)
    (is = 98 (bst:previous (nth-value 1 (bst:find tree 100))))
    (false (bst:previous (nth-value 1 (bst:find tree 1))))))

(define-test bst/next
  (let ((tree (bst:make-tree)))
    (dotimes (i 100)
      (bst:insert tree (1+ i)))
    (is = 2 (bst:next (nth-value 1 (bst:find tree 1))))
    (bst:delete tree 2)
    (is = 3 (bst:next (nth-value 1 (bst:find tree 1))))
    (false (bst:next (nth-value 1 (bst:find tree 100))))))
