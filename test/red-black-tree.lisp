(in-package #:cl.lisp.collections.test)

(define-test rbt/make-tree
  (let ((tree (rbt:make-tree)))
    (of-type rbt::tree tree)
    (false (rbt::node-p (rbt::root tree)))
    (is eq #'identity (rbt::key tree))
    (is eq #'< (rbt::test tree))))

(define-test rbt/valid-p
  (dotimes (i 10)
    (let ((tree (rbt:make-tree)))
      (dotimes (i 1000)
        (rbt:insert tree (random 1d0)))
      (true (rbt:valid-p tree))))
  (let ((tree (rbt:make-tree)))
    (dotimes (i 10)
      (rbt:insert tree (1+ i)))
    (setf (rbt::data (rbt::root tree)) 42)
    (false (rbt:valid-p tree))))

(define-test rbt/walk
  (let ((tree (rbt:make-tree))
        (input '(8 2 5 1 4 9 3 10 7 6))
        (result nil))
    (false (rbt:walk tree))
    (dotimes (i 10)
      (rbt:insert tree (pop input)))
    (false (rbt:walk tree))
    (rbt:walk tree (lambda (x) (push (* x 10) result)))
    (is equal '(10 20 30 40 50 60 70 80 90 100) (reverse result))))

(define-test rbt/find
  (let ((tree (rbt:make-tree)))
    (false (rbt:find tree 42))
    (rbt:insert tree 420)
    (rbt:insert tree 621)
    (dotimes (i 1000)
      (rbt:insert tree (random 1000.0)))
    (is = 420 (rbt:find tree 420))
    (of-type rbt::node (nth-value 1 (rbt:find tree 621)))
    (setf tree (rbt:make-tree :key #'cdr))
    (rbt:insert tree '(:foo . 420))
    (dotimes (i 1000)
      (rbt:insert tree `(:bar . ,(random 1000.0))))
    (is = 420 (cdr (rbt:find tree 420)))
    (fail (rbt:find tree :foo))
    (fail (rbt:find tree '(:foo . 420)))))

(define-test rbt/insert
  (let ((tree (rbt:make-tree)))
    (of-type rbt::node (rbt:insert tree 42))
    (is = 42 (rbt:find tree 42))))

(define-test rbt/delete
  (let ((tree (rbt:make-tree)))
    (of-type rbt::tree (rbt:delete tree 1))
    (false (nth-value 1 (rbt:delete tree 1)))
    (dotimes (i 1000)
      (rbt:insert tree (1+ i)))
    (true (nth-value 1 (rbt:delete tree 1)))
    (false (rbt:find tree 1))
    (setf tree (rbt:make-tree :key #'cdr))
    (rbt:insert tree '(:foo . 1))
    (dotimes (i 1000)
      (rbt:insert tree `(:bar . ,(+ 2 (random 1000.0)))))
    (true (nth-value 1 (rbt:delete tree 1)))
    (false (rbt:find tree 1))))

(define-test rbt/min
  (let ((tree (rbt:make-tree)))
    (false (rbt:min tree))
    (dotimes (i 1000)
      (rbt:insert tree (1+ i)))
    (is = 1 (rbt:min tree))
    (setf tree (rbt:make-tree :key #'cdr))
    (dotimes (i 200)
      (rbt:insert tree `(:foo . ,(+ 200 (random 200.0)))))
    (rbt:insert tree '(:bar . 199))
    (rbt:insert tree '(:baz . 50))
    (dotimes (i 500)
      (rbt:insert tree `(:qux . ,(+ 400 (random 500.0)))))
    (is = 50 (cdr (rbt:min tree)))
    (rbt:delete tree 50)
    (is = 199 (cdr (rbt:min tree)))))

(define-test rbt/max
  (let ((tree (rbt:make-tree)))
    (false (rbt:max tree))
    (dotimes (i 1000)
      (rbt:insert tree (1+ i)))
    (is = 1000 (rbt:max tree))
    (setf tree (rbt:make-tree :key #'cdr))
    (dotimes (i 200)
      (rbt:insert tree `(:foo . ,(random 200.0))))
    (rbt:insert tree '(:bar . 700))
    (rbt:insert tree '(:baz . 999))
    (dotimes (i 500)
      (rbt:insert tree `(:qux . ,(+ 200 (random 500.0)))))
    (is = 999 (cdr (rbt:max tree)))
    (rbt:delete tree 999)
    (is = 700 (cdr (rbt:max tree)))))

(define-test rbt/previous
  (let ((tree (rbt:make-tree)))
    (dotimes (i 100)
      (rbt:insert tree (1+ i)))
    (is = 99 (rbt:previous (nth-value 1 (rbt:find tree 100))))
    (rbt:delete tree 99)
    (is = 98 (rbt:previous (nth-value 1 (rbt:find tree 100))))
    (false (rbt:previous (nth-value 1 (rbt:find tree 1))))))

(define-test rbt/next
  (let ((tree (rbt:make-tree)))
    (dotimes (i 100)
      (rbt:insert tree (1+ i)))
    (is = 2 (rbt:next (nth-value 1 (rbt:find tree 1))))
    (rbt:delete tree 2)
    (is = 3 (rbt:next (nth-value 1 (rbt:find tree 1))))
    (false (rbt:next (nth-value 1 (rbt:find tree 100))))))
