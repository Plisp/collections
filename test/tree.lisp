(in-package #:cl.lisp.collections.test)

(defun tree/make-tree (type)
  (subtest (format nil "~a: make-tree" type)
    (plan 4)
    (let ((tree (tree:make-tree type :item-type 'atom)))
      (is-type tree type "tree type")
      (ok (null (tree::node-p (tree::root tree))) "default root empty")
      (is (tree::key tree) #'identity "default key")
      (is (tree::sorter tree) #'< "default sorter"))
    (finalize)))

(defun tree/valid-p (type)
  (subtest (format nil "~a: valid-p" type)
    (plan 1)
    (let ((results nil))
      (dotimes (i 1000)
        (let ((tree (tree:make-tree type :item-type 'double-float)))
          (dotimes (i 100)
            (tree:insert tree (random 1d0)))
          (push (tree:valid-p tree) results)))
      (ok (notany #'null results) "1000 random trees valid"))
    (finalize)))

(defun tree/walk (type)
  (subtest (format nil "~a: walk" type)
    (plan 3)
    (let ((tree (tree:make-tree type :item-type 'integer))
          (input (loop :repeat 10000 :collect (random 100d0)))
          (result nil))
      (ok (null (tree:walk tree #'identity)) "returns nil when tree is empty")
      (dolist (x input)
        (tree:insert tree x))
      (ok (null (tree:walk tree #'identity))
          "returns nil when tree is populated")
      (tree:walk tree (lambda (x) (push x result)))
      (is result (stable-sort (copy-seq input) #'>)
          "in-order traversal visits nodes in correct order"))
    (finalize)))

(defun tree/find (type)
  (subtest (format nil "~a: find" type)
    (plan 6)
    (let ((tree (tree:make-tree 'tree:binary-search-tree :item-type 'real)))
      (is-values (tree:find tree 42) '(nil nil)
        "fresh tree has nothing to be found")
      (tree:insert tree 420)
      (tree:insert tree 621)
      (dotimes (i 10000)
        (tree:insert tree (random 1000d0)))
      (is (tree:find tree 420) 420
          "find by identity returns item as first value")
      (is-type (nth-value 1 (tree:find tree 621)) 'tree:node
               "find by identity returns node as second value")
      (setf tree (tree:make-tree 'tree:binary-search-tree
                                 :item-type 'cons
                                 :key #'cdr
                                 :hash-test #'equal))
      (tree:insert tree '(:foo . 420))
      (dotimes (i 1000)
        (tree:insert tree `(:bar . ,(random 1000d0))))
      (is (tree:find tree '(:foo . 420)) '(:foo . 420)
          "find by custom key returns item as first value")
      (is-type (nth-value 1 (tree:find tree '(:foo . 420))) 'tree:node
               "find by custom key returns node as second value")
      (ok (null (tree:find tree 420))
          "find by custom key requires item, not key"))
    (finalize)))

(defun tree/insert (type)
  (subtest (format nil "~a: insert" type)
    (plan 2)
    (let ((tree (tree:make-tree 'tree:binary-search-tree :item-type 'integer)))
      (is-type (tree:insert tree 42) 'tree:node "returns node")
      (is (tree:find tree 42) 42 "found after inserted"))
    (finalize)))

(defun tree/delete (type)
  (subtest (format nil "~a: delete" type)
    (plan 5)
    (let ((tree (tree:make-tree 'tree:binary-search-tree
                                :item-type 'double-float)))
      (ok (null (tree:delete tree 1d0)) "returns nil when tree is empty")
      (tree:insert tree 800d0)
      (dotimes (i 10000)
        (tree:insert tree (random 100d0)))
      (ok (tree:delete tree 800d0) "delete known item returns non-nil")
      (ok (null (tree:find tree 800d0))
          "delete already deleted item returns nil")
      (setf tree (tree:make-tree 'tree:binary-search-tree
                                 :item-type 'cons
                                 :key #'cdr))
      (tree:insert tree '(:foo . 1d0))
      (dotimes (i 1000)
        (tree:insert tree `(:bar . ,(+ 2 (random 1000d0)))))
      (ok (tree:delete tree '(:foo . 1d0))
          "delete by custom key for known item returns non-nil")
      (ok (null (tree:find tree 1d0))
          "delete by custom key for already deleted item returns nil"))
    (finalize)))

(defun tree/min (type)
  (subtest (format nil "~a: min" type)
    (plan 6)
    (let ((tree (tree:make-tree 'tree:binary-search-tree
                                :item-type 'double-float)))
      (ok (null (tree:min tree)) "no minimum for empty tree")
      (tree:insert tree 1d0)
      (dotimes (i 10000)
        (tree:insert tree (+ 2 (random 100d0))))
      (is-type (tree:min tree) 'tree:node "returns node object")
      (is (tree::key (tree:min tree)) 1d0 "correct minimum")
      (tree:delete tree 1d0)
      (isnt (tree::key (tree:min tree)) 1d0
            "after deleting previous minimum node")
      (setf tree (tree:make-tree 'tree:binary-search-tree
                                 :item-type 'cons
                                 :key #'cdr))
      (dotimes (i 200)
        (tree:insert tree `(:foo . ,(+ 200 (random 200d0)))))
      (tree:insert tree '(:bar . 199d0))
      (tree:insert tree '(:baz . 50d0))
      (dotimes (i 500)
        (tree:insert tree `(:qux . ,(+ 400 (random 500d0)))))
      (is (tree::key (tree:min tree)) 50d0 "tree with custom key")
      (tree:delete tree '(:baz . 50d0))
      (is (tree::key (tree:min tree)) 199d0
          "tree with custom key after deleting previous minimum"))
    (finalize)))

(defun tree/max (type)
  (subtest (format nil "~a: max" type)
    (plan 6)
    (let ((tree (tree:make-tree 'tree:binary-search-tree
                                :item-type 'double-float)))
      (ok (null (tree:max tree)) "no maximum for empty tree")
      (tree:insert tree 1000d0)
      (dotimes (i 10000)
        (tree:insert tree (+ 2 (random 100d0))))
      (is-type (tree:max tree) 'tree:node "returns node object")
      (is (tree::key (tree:max tree)) 1000d0 "correct maximum")
      (tree:delete tree 1000d0)
      (isnt (tree::key (tree:max tree)) 1000d0
            "after deleting previous maximum node")
      (setf tree (tree:make-tree 'tree:binary-search-tree
                                 :item-type 'cons
                                 :key #'cdr))
      (dotimes (i 200)
        (tree:insert tree `(:foo . ,(random 200d0))))
      (tree:insert tree '(:bar . 700d0))
      (tree:insert tree '(:baz . 999d0))
      (dotimes (i 500)
        (tree:insert tree `(:qux . ,(+ 200 (random 500d0)))))
      (is (tree::key (tree:max tree)) 999d0 "tree with custom key")
      (tree:delete tree '(:baz . 999d0))
      (is (tree::key (tree:max tree)) 700d0
          "tree with custom key returns after deleting previous maximum"))
    (finalize)))

(defun tree/previous (type)
  (subtest (format nil "~a: previous" type)
    (plan 3)
    (let ((tree (tree:make-tree 'tree:binary-search-tree :item-type 'integer)))
      (dotimes (i 1000)
        (tree:insert tree (1+ i)))
      (is (tree::key (tree:previous (nth-value 1 (tree:find tree 100)))) 99
          "previous node correct")
      (tree:delete tree 99)
      (is (tree::key (tree:previous (nth-value 1 (tree:find tree 100)))) 98
          "previous node correct after deletion")
      (ok (null (tree:previous (nth-value 1 (tree:find tree 1))))
          "previous of minimum is nil"))
    (finalize)))

(defun tree/next (type)
  (subtest (format nil "~a: next" type)
    (plan 3)
    (let ((tree (tree:make-tree 'tree:binary-search-tree :item-type 'integer)))
      (dotimes (i 1000)
        (tree:insert tree (1+ i)))
      (is (tree::key (tree:next (nth-value 1 (tree:find tree 1)))) 2
          "next node correct")
      (tree:delete tree 2)
      (is (tree::key (tree:next (nth-value 1 (tree:find tree 1)))) 3
          "next node correct after deletion")
      (ok (null (tree:next (nth-value 1 (tree:find tree 1000))))
          "next of maximum is nil"))
    (finalize)))

(plan 40)

(dolist (type '(tree:binary-search-tree
                tree:red-black-tree
                tree:avl-tree
                tree:splay-tree))
  (diag (format nil "begin: ~a" type))
  (tree/make-tree type)
  (tree/valid-p type)
  (tree/walk type)
  (tree/find type)
  (tree/insert type)
  (tree/delete type)
  (tree/min type)
  (tree/max type)
  (tree/previous type)
  (tree/next type)
  (diag (format nil "end: ~a" type)))

(finalize)
